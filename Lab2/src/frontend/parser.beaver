// package the generated Java class lives in; no need to change this
%package "parser";

// name of the generated Java class; no need to change this
%class "Parser";

// no need to change this either
%embed {:
	// turn off automated error recovery
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws java.io.IOException, Exception {
		super.recoverFromError(new Symbol(0), in);
	}
:};

// the list of all terminals; no need to change this
%terminals MODULE, INT, VOID, IF, ELSE, WHILE, RETURN, BREAK, BOOLEAN, PUBLIC, TRUE, FALSE,
           INT_LITERAL, STRING_LITERAL, ID, TYPE, IMPORT,
           PLUS, MINUS, TIMES, DIV, MOD, EQEQ, NEQ, LEQ, GEQ, LT, GT,
           LBRACKET, RPAREN, COMMA, RCURLY, LCURLY, SEMICOLON, RBRACKET, LPAREN, EQL;
           
// declaration of start symbol; no need to change this
%goal Module;

// A module consists of the keyword module,
// followed by an identifier (which is the module’s name),
// followed by an opening curly brace,
// followed by imports,
// followed by declarations,
// followed by a closing curly brace.
Module = MODULE ID LCURLY Imports Declarations RCURLY;

// A module’s imports (nonterminal Imports) specify what other modules this module will import.
// They consist of zero or more import statements.
Imports = Import Imports
          |
          ;

// An import statement (nonterminal Import) consists of
// the keyword import,
// followed by an identifier,
// followed by a semicolon.
// The identifier is the name of a module to be imported.
Import = IMPORT ID SEMICOLON;

// A module’s declarations (nonterminal Declarations) consist of zero or more declarations.
// A declaration is either a function declaration, or a field declaration, or a type declaration.
Declarations = Function_Declaration Declarations
               | Field_Declaration Declarations
               | Type_Declaration Declarations
               |
               ;

// A function declaration consists of an accessibility specifier, a type name, an identifier, an opening parenthesis,
// a parameter list, a closing parenthesis, an opening curly brace, a possibly empty list of statements,
// and a closing curly brace.
Function_Declaration = Accessibility_Specifier Type_Name ID LPAREN Parameter_List RPAREN LCURLY List_Of_Statements RCURLY;

// A field declaration consists of an accessibility specifier, a type name, an identifier, and a semicolon.
Field_Declaration = Accessibility_Specifier Type_Name ID SEMICOLON;

// A type declaration consists of an accessibility specifier, the keyword type, an identifier,
// a single equals symbol, a string literal, and a semicolon.
Type_Declaration = Accessibility_Specifier TYPE ID EQL STRING_LITERAL SEMICOLON;

// An accessibility specifier consists of either the keyword public, or of nothing at all.
Accessibility_Specifier = PUBLIC
                          |
                          ;

// A type name is either a primitive type, an array type, or an identifier.
Type_Name = Primitive_Type
            | Array_Type
            | ID
            ;

// A primitive type is one of the keywords void, boolean and int.
Primitive_Type = VOID | BOOLEAN | INT;

// An array type is a type name, followed by a left bracket, followed by a right bracket.
Array_Type = Primitive_Type LBRACKET RBRACKET
             | Array_Type LBRACKET RBRACKET
             | ID LBRACKET RBRACKET
             ;

// A parameter list is a possibly empty list of parameters separated by commas.
Parameter_List = Parameter COMMA Parameter_List
                 | Parameter
                 |
                 ;

// A parameter is a type name followed by an identifier.
Parameter = Type_Name ID;

// A statement is one of the following.
Statement = Local_Variable_Declaration
            | Block_Of_Statements
            | If_Statement
            | While_Statement
            | Break_Statement
            | Return_Statement
            | Expression_Statement
            ;

// A local variable declaration consists of a type name,
// followed by an identifier,
// followed by a semicolon.
Local_Variable_Declaration = Type_Name ID SEMICOLON;

// A block of statements consists of an opening curly brace,
// followed by a possibly empty list of statements,
// followed by a closing curly brace.
Block_Of_Statements = LCURLY List_Of_Statements RCURLY;

List_Of_Statements = Statement List_Of_Statements
                     |
                     ;

// An if statement consists of an if keyword, an opening parenthesis, an expression,
// a closing parenthesis, a statement, an else keyword, and another statement;
// optionally, the else keyword and the last statement may be missing.
If_Statement = IF LPAREN Expression RPAREN Statement
               | IF LPAREN Expression RPAREN Statement ELSE Statement
               ;

// A while statement consists of a while keyword, an opening parenthesis, an expression,
// a closing parenthesis, and a statement.
While_Statement = WHILE LPAREN Expression RPAREN Statement;

// A break statement consists of a break keyword followed by a semicolon.
Break_Statement = BREAK SEMICOLON;

// A return statement consists of a return keyword, followed by an optional expression,
// followed by a semicolon.
Return_Statement = RETURN SEMICOLON
                   | RETURN Expression SEMICOLON
                   ;

// An expression statement consists of an expression followed by a semicolon.
Expression_Statement = Expression SEMICOLON;

// An expression is either an assignment or a right hand side expression.
Expression = Assignment
             | Right_Hand_Side_Expression
             ;

// An assignment is a left hand side expression, followed by a single equals sign, followed by an expression.
Assignment = Left_Hand_Side_Expression EQL Expression;

// A left hand side expression is either an identifier or an array access.
Left_Hand_Side_Expression = ID | Array_Access;

// An array access is a left hand side expression, followed by an opening bracket,
// followed by an expression, followed by a closing bracket.
Array_Access = ID LBRACKET Expression RBRACKET
               | Array_Access LBRACKET Expression RBRACKET;

// A right hand side expression is an arithmetic expression,
// optionally followed by a comparison operator and another arithmetic expression.
Right_Hand_Side_Expression = Arithmetic_Expression
                             | Arithmetic_Expression Comparison_Operator Arithmetic_Expression;

// A comparison operator is one of EQEQ, NEQ, LT, LEQ, GT, GEQ.
Comparison_Operator = EQEQ | NEQ | LT | LEQ | GT | GEQ;

// An arithmetic expression is either an arithmetic expression, followed by an additive operator,
// followed by a term; or just a term.
Arithmetic_Expression = Arithmetic_Expression Additive_Operator Term
                        | Term
                        ;

// An additive operator is either PLUS or MINUS.
Additive_Operator = PLUS | MINUS;

// A term is either a term, followed by a multiplicative operator, followed by a factor; or just a factor.
Term = Term Multiplicative_Operator Factor
       | Factor
       ;

// A multiplicative operator is one of TIMES, DIV, MOD.
Multiplicative_Operator = TIMES | DIV | MOD;

// A factor is either a MINUS followed by a factor, or a primary expression.
Factor = MINUS Factor
         | Primary_Expression;

// A primary expression is one of the following.
Primary_Expression = Left_Hand_Side_Expression
                     | Function_Call
                     | Array_Expression
                     | STRING_LITERAL
                     | INT_LITERAL
                     | TRUE
                     | FALSE
                     | Parenthesised_Expression
                     ;

// A function call is an identifier, followed by an opening parenthesis, followed by a possibly empty list of
// expressions separated by comma, followed by a closing parenthesis.
Function_Call = ID LPAREN List_Of_Expressions RPAREN;

List_Of_Expressions = Expression COMMA List_Of_Expressions
                      | Expression
                      |
                      ;

// An array expression is an opening bracket, followed by a non-empty list of expressions separated by comma,
// followed by a closing bracket.
Array_Expression = LBRACKET Expression RBRACKET
                   | LBRACKET Expression COMMA List_Of_Expressions RBRACKET
                   ;

// A parenthesised expression is an opening parenthesis, followed by an expression, followed by a closing parenthesis.
Parenthesised_Expression = LPAREN Expression RPAREN;

/**/